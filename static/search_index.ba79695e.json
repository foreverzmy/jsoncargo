[{"id":0,"title":"ObservableObject","content":"#\n\nThe ObservableObject class provides a mechanism to observe changes to the\nproperties of an object. It allows setting values on the object and watching for\nchanges at specific paths, including nested properties, making it suitable for\ncomplex state management scenarios.\n\n\nPropertyName#\n\n\n\nPropertyName refers to the various ways you can specify a property name when\nusing methods that deal with object properties.\n\nIt uses lodash's API internally, so its behavior is consistent with lodash.get\nand lodash.setWith and lodash.toPath methods when operating the target objects.\n\n\nClass Definition#\n\n\nConstructor#\n\nCreates a new ObservableObject instance.\n\n\n\n * target: The initial object to observe. This object is deeply cloned to avoid\n   direct mutations.\n\n\nProperties#\n\n * value: Returns a deep clone of the target object.\n\n\nMethods#\n\nset#\n\nSets a value at a specific path within the object and notifies watchers if the\nvalue changes.\n\n\n\n * values: Set the full object to replace target if just only one parameters.\n * path: The path where the value should be set (can be a string or an array of\n   strings).\n * value: The new value to set at the specified path.\n * customizer (optional): The function to customize assigned values.\n\nReturns the new value at the specified path.\n\nget#\n\nGets the value at a specific path or the entire object if no path is provided.\n\n\n\n * path (optional): The path to retrieve the value from (can be a string or an\n   array of strings).\n\nReturns the deep clone value at the specified path or a deep clone of the entire\nobject if no path is provided.\n\nunset#\n\nDelete the value at a specific path.\n\n\n\n * path: The path to delete.\n\nReturns the value at the specified path to delete, if the path not exists, it\nwill be undefined.\n\nwatch#\n\nWatches for changes at a specific path and executes a callback when changes\noccur.\n\n\n\n * path: The path to watch for changes.\n * callback: The function to execute when a change occurs.\n * options (optional): An object with the following optional properties:\n   * leading: If true, the callback is executed immediately with the current\n     value at the path.\n\nReturns a function to unsubscribe from the watch.\n\n\nUsage#\n\n\nCreating an ObservableObject#\n\n\n\n\nGetting Values#\n\n\n\n\nSetting Values#\n\n\n\n> Note: If the value being set is equal to the existing value, watchers will not\n> be triggered.\n\n\nDelete Path and Value#\n\n\n\n\nWatching for Changes#\n\n\n\n\nWatching Nested Properties#\n\n\n\n\nAdvanced Usage#\n\n\nRoot Watcher#\n\nTo watch for any change in the object:\n\n\n\n\nWatching Parent and Child Paths#\n\nThe ObservableObject automatically detects changes to parent and child paths. If\na parent path is watched, any change to a child path will trigger the callback.\n\n\n\n\nConclusion#\n\nThe ObservableObject class provides a powerful way to manage and react to\nchanges within an object. It supports deep observation of nested properties,\nmaking it suitable for complex state management scenarios. Watchers will not be\ntriggered if the new value is equal to the old value, ensuring efficient change\ndetection.","routePath":"/api/ObservableObject","lang":"","toc":[{"text":"PropertyName","id":"propertyname","depth":2,"charIndex":274},{"text":"Class Definition","id":"class-definition","depth":2,"charIndex":578},{"text":"Constructor","id":"constructor","depth":3,"charIndex":598},{"text":"Properties","id":"properties","depth":3,"charIndex":759},{"text":"Methods","id":"methods","depth":3,"charIndex":827},{"text":"`set`","id":"set","depth":4,"charIndex":-1},{"text":"`get`","id":"get","depth":4,"charIndex":-1},{"text":"`unset`","id":"unset","depth":4,"charIndex":-1},{"text":"`watch`","id":"watch","depth":4,"charIndex":-1},{"text":"Usage","id":"usage","depth":2,"charIndex":2180},{"text":"Creating an ObservableObject","id":"creating-an-observableobject","depth":3,"charIndex":2189},{"text":"Getting Values","id":"getting-values","depth":3,"charIndex":2223},{"text":"Setting Values","id":"setting-values","depth":3,"charIndex":2243},{"text":"Delete Path and Value","id":"delete-path-and-value","depth":3,"charIndex":2361},{"text":"Watching for Changes","id":"watching-for-changes","depth":3,"charIndex":2388},{"text":"Watching Nested Properties","id":"watching-nested-properties","depth":3,"charIndex":2414},{"text":"Advanced Usage","id":"advanced-usage","depth":2,"charIndex":2446},{"text":"Root Watcher","id":"root-watcher","depth":3,"charIndex":2464},{"text":"Watching Parent and Child Paths","id":"watching-parent-and-child-paths","depth":3,"charIndex":2522},{"text":"Conclusion","id":"conclusion","depth":2,"charIndex":2721}],"domain":"","frontmatter":{"pageType":"doc"},"version":""},{"id":1,"title":"getDeltaByPath","content":"#\n\nThe getDeltaByPath method is a tool of jsondiffpatch utility designed to extract\na specific delta (change set) from a larger delta object representing\ndifferences between two JSON objects. This method is useful for retrieving\nprecise change information at a given path within the JSON structure.\n\n\nDelta Types#\n\n * AddedDelta: Represents an added value.\n * ModifiedDelta: Represents a change from one value to another.\n * DeletedDelta: Represents a deleted value.\n * ObjectDelta: A complex object structure representing changes in a nested JSON\n   object.\n * ArrayDelta: Represents changes in an array, including additions, deletions,\n   and modifications.\n * MovedDelta: Represents a moved value within an array.\n * TextDiffDelta: Represents a textual difference.\n\n\nFunction Signature#\n\n\n\n\nParameters#\n\n * delta: The root delta object from which changes are extracted.\n * path: The path to the specific change within the delta object. It can be a\n   string or an array of strings representing the path to the desired change.\n\n\nReturn Value#\n\nReturns a Delta object representing the change at the specified path. If no\nchange exists at that path or the path is invalid, the function returns\nundefined.\n\n\nUsage#\n\nTo use the getDeltaByPath function, you need to pass the complete delta object\nand the path to the specific change you want to retrieve. The path can be a\ndot-separated string (e.g., \"user.name\") or an array of strings representing the\nkeys and indexes in the path (e.g., [\"user\", \"name\"]).\n\n\nExample#\n\n\n\n\nNotes#\n\n * The function handles different types of deltas and navigates through the\n   nested structure based on the provided path.\n * For ArrayDelta and ObjectDelta, the function recursively searches for the\n   specified path.\n * For simple deltas like AddedDelta, ModifiedDelta, and DeletedDelta, it\n   directly returns the corresponding change if it matches the path.\n\n\nConclusion#\n\nThe getDeltaByPath method is a powerful tool for navigating complex delta\nobjects and extracting specific changes, making it easier to understand and\nhandle the differences between JSON objects in a fine-grained manner.","routePath":"/api/getDeltaByPath","lang":"","toc":[{"text":"Delta Types","id":"delta-types","depth":2,"charIndex":300},{"text":"Function Signature","id":"function-signature","depth":2,"charIndex":769},{"text":"Parameters","id":"parameters","depth":2,"charIndex":793},{"text":"Return Value","id":"return-value","depth":2,"charIndex":1030},{"text":"Usage","id":"usage","depth":2,"charIndex":1206},{"text":"Example","id":"example","depth":2,"charIndex":1507},{"text":"Notes","id":"notes","depth":2,"charIndex":1520},{"text":"Conclusion","id":"conclusion","depth":2,"charIndex":1893}],"domain":"","frontmatter":{"pageType":"doc"},"version":""},{"id":2,"title":"getDeltaType","content":"#\n\nThe getDeltaType method is a tool of jsondiffpatch that generates a delta object\nrepresenting the difference between two JSON values. This method analyzes a\ndelta object to determine the type of change it represents. The delta types\ninclude added, deleted, modified, unchanged, and unknown.\n\n\nFunction Signature#\n\n\n\n\nParameters#\n\n * delta: The delta object to inspect.\n * path: An optional path (string or array of strings) to a specific part of the\n   delta object.\n * options: An optional object with the following properties:\n   * deep: A boolean indicating whether to inspect deeply into nested objects\n     and arrays.\n\n\nReturn Value#\n\nThe function returns a value from the DELTA_TYPE enum, indicating the type of\nchange detected:\n\n\n\n\nUsage#\n\n\n\n\nNotes#\n\nThe method handles different structures of delta objects, including arrays and\nobjects, and interprets them according to the specified path and options.\n\nThe deep option allows for detailed inspection of nested structures within the\ndelta object, providing flexibility in how changes are detected and classified.","routePath":"/api/getDeltaType","lang":"","toc":[{"text":"Function Signature","id":"function-signature","depth":2,"charIndex":295},{"text":"Parameters","id":"parameters","depth":2,"charIndex":319},{"text":"Return Value","id":"return-value","depth":2,"charIndex":628},{"text":"Usage","id":"usage","depth":2,"charIndex":742},{"text":"Notes","id":"notes","depth":2,"charIndex":753}],"domain":"","frontmatter":{"pageType":"doc"},"version":""},{"id":3,"title":"getSchemaByPath","content":"#\n\nThe getSchemaByPath function is designed to navigate through a JSON Schema and\nretrieve the schema definition at a specified path. This utility is particularly\nuseful in applications that need to validate or process nested structures within\na JSON object based on its schema.\n\n\nTypes#\n\n * Json: Represents any valid JSON value.\n * JsonType: Enumerates the possible JSON types.\n * JsonSchemaType: Extends JsonType with an additional 'integer' type for more\n   precise schema definitions.\n * JsonSchema: Represents a JSON Schema with various properties that define\n   validation rules.\n\n\nFunction Signature#\n\n\n\n\nParameters#\n\n * schema: The root JSON Schema object from which the path traversal begins.\n * path: A string or array of strings representing the path to traverse within\n   the JSON Schema. Paths are dot-separated for string input.\n\n\nReturn Value#\n\n * Returns the JsonSchema object located at the specified path within the input\n   schema.\n * If the path does not exist or the traversal fails, undefined is returned.\n\n\nUsage#\n\n\nObject Schema Navigation#\n\nWhen navigating an object schema, getSchemaByPath follows the properties,\npatternProperties, additionalProperties, and unevaluatedProperties keys to find\nthe nested schema.\n\nFor example:\n\n * Given a path user.name, it will attempt to find the schema for the name\n   property within the user object.\n * If name matches a pattern in patternProperties, that schema will be returned.\n\n\nArray Schema Navigation#\n\nFor array schemas, the function handles both indexed and unindexed items:\n\n * Paths that are numeric (or numeric strings) will attempt to find the schema\n   for the item at that index in the items array.\n * If the index is out of bounds or the items is a single schema object,\n   additionalItems schema is considered.\n\n\nExample#\n\n\n\nIn this example, getSchemaByPath retrieves the schema for the name property\nwithin the user object, returning { type: \"string\" }.\n\n\nConclusion#\n\nThe getSchemaByPath function is a powerful tool for dynamically accessing nested\nschemas within a larger JSON Schema structure, enabling developers to implement\ncomplex validation and processing logic based on schema definitions.","routePath":"/api/getSchemaByPath","lang":"","toc":[{"text":"Types","id":"types","depth":2,"charIndex":280},{"text":"Function Signature","id":"function-signature","depth":2,"charIndex":588},{"text":"Parameters","id":"parameters","depth":2,"charIndex":612},{"text":"Return Value","id":"return-value","depth":2,"charIndex":845},{"text":"Usage","id":"usage","depth":2,"charIndex":1030},{"text":"Object Schema Navigation","id":"object-schema-navigation","depth":3,"charIndex":1039},{"text":"Array Schema Navigation","id":"array-schema-navigation","depth":3,"charIndex":1448},{"text":"Example","id":"example","depth":2,"charIndex":1794},{"text":"Conclusion","id":"conclusion","depth":2,"charIndex":1938}],"domain":"","frontmatter":{"pageType":"doc"},"version":""},{"id":4,"title":"Introduction","content":"Install#\n\n\n\n\nIntroduction#\n\nThe jsoncargo package provides a versatile set of tools designed to interact\nwith and manipulate JSON objects. It aims to simplify various operations\ninvolving JSON data, making it easier for developers to work with complex JSON\nstructures. Here are some key features and functionalities included in the\npackage:\n\n 1. Path-Based Access and Manipulation: jsoncargo allows users to access,\n    modify, and delete values within a JSON object using path-based syntax. This\n    makes it straightforward to navigate through nested structures.\n\n 2. Schema Retrieval: The getSchemaByPath function enables users to retrieve the\n    schema of a specific path within a JSON object. This is particularly useful\n    for understanding the structure and types of data expected at various points\n    within a JSON document.\n\n 3. Dynamic Value Setting: The package supports dynamic setting of values within\n    JSON objects, allowing for flexible and programmatic updates to the data.\n\n 4. Change Watching: jsoncargo includes functionality to watch for changes\n    within a JSON object, making it easier to track and respond to modifications\n    in real-time.\n\n 5. Validation and Type Checking: The tools provide built-in validation and type\n    checking to ensure data integrity and consistency throughout the\n    manipulation process.\n\n 6. Utility Functions: A variety of utility functions are included to perform\n    common operations such as deep cloning, merging, and comparing JSON objects.\n\njsoncargo is designed to be lightweight and easy to integrate into existing\nprojects, providing a robust solution for developers who frequently work with\nJSON data. The package is available on npm and can be easily installed and\nutilized within any JavaScript or TypeScript project.","routePath":"/api/","lang":"","toc":[],"domain":"","frontmatter":{"pageType":"doc"},"version":""},{"id":5,"title":"jsonMergePatch","content":"#\n\nAn implementation of the JSON Merge Patch RFC 7396.\n\nJSON Merge Patch (RFC 7396) is a standard format that allows you to update a\nJSON document by sending the changes rather than the whole document. JSON Merge\nPatch plays well with the HTTP PATCH verb (method) and REST style programming.\n\nThere are three functions (merge, apply, and generate) for manipulating JSON\nobjects. These functions are used for applying patches to JSON objects, merging\nJSON objects, and generating patches based on differences between JSON objects.\n\n\njsonMergePatch.merge#\n\nMerges a patch JSON object into an original JSON object. If either the original\nor the patch is not a valid JSON object, it returns a deep clone of the patch.\n\n\nTypes#\n\n * Json: Represents any valid JSON value.\n\n\nFunction Signature#\n\n\n\n\nParameters#\n\n * original: The original JSON object to be merged.\n * patch: The patch JSON object to merge into the original.\n\n\nReturn Value#\n\n * Returns the Json object that is the merged result.\n\n\nUsage#\n\n\n\n\njsonMergePatch.apply#\n\nApplies a patch to a target JSON object. If the patch or the target is not a\nvalid JSON object, the target is replaced with a deep clone of the patch.\n\n\nTypes#\n\n * Json: Represents any valid JSON value.\n\n\nFunction Signature#\n\n\n\n\nParameters#\n\n * target: The target JSON object to which the patch will be applied.\n * patch: The patch JSON object to apply to the target.\n\n\nReturn Value#\n\n * Return the updated JSON object after applying the patch.\n\n\nUsage#\n\n\n\n\njsonMergePatch.generate#\n\nGenerates a patch JSON object that represents the differences between the\noriginal and result JSON objects. If either the original or the result is not a\nvalid JSON object, it returns a deep clone of the result.\n\n\nTypes#\n\n * Json: Represents any valid JSON value.\n\n\nFunction Signature#\n\n\n\n\nParameters#\n\n * original: The original JSON object.\n * result: The resulting JSON object to compare with the original.\n\n\nReturn Value#\n\n * Return the generated patch JSON object.\n\n\nUsage#\n\n","routePath":"/api/jsonMergePatch","lang":"","toc":[{"text":"`jsonMergePatch.merge`","id":"jsonmergepatchmerge","depth":2,"charIndex":-1},{"text":"Types","id":"types","depth":3,"charIndex":715},{"text":"Function Signature","id":"function-signature","depth":3,"charIndex":767},{"text":"Parameters","id":"parameters","depth":3,"charIndex":791},{"text":"Return Value","id":"return-value","depth":3,"charIndex":918},{"text":"Usage","id":"usage","depth":3,"charIndex":989},{"text":"`jsonMergePatch.apply`","id":"jsonmergepatchapply","depth":2,"charIndex":-1},{"text":"Types","id":"types-1","depth":3,"charIndex":1176},{"text":"Function Signature","id":"function-signature-1","depth":3,"charIndex":1228},{"text":"Parameters","id":"parameters-1","depth":3,"charIndex":1252},{"text":"Return Value","id":"return-value-1","depth":3,"charIndex":1393},{"text":"Usage","id":"usage-1","depth":3,"charIndex":1470},{"text":"`jsonMergePatch.generate`","id":"jsonmergepatchgenerate","depth":2,"charIndex":-1},{"text":"Types","id":"types-2","depth":3,"charIndex":1721},{"text":"Function Signature","id":"function-signature-2","depth":3,"charIndex":1773},{"text":"Parameters","id":"parameters-2","depth":3,"charIndex":1797},{"text":"Return Value","id":"return-value-2","depth":3,"charIndex":1918},{"text":"Usage","id":"usage-2","depth":3,"charIndex":1978}],"domain":"","frontmatter":{"pageType":"doc"},"version":""},{"id":6,"title":"threeWayMerge","content":"#\n\nThe threeWayMerge function performs a three-way merge on two JSON objects (left\nand right) with a common ancestor (base). It identifies and resolves conflicts\nbetween the changes made in the left and right JSON objects. If conflicts are\ndetected, the method returns the conflict paths; otherwise, it merges the\nchanges and returns the resulting JSON object.\n\n\nTypes#\n\n\nPathType#\n\nThe PathType type represents the path to a value within a JSON object or array.\nIt can be either a string (for object keys) or a number (for array indices).\nThis type is used to specify the location of conflicts within the JSON\nstructure.\n\n\n\n\nPatch Options#\n\nThe patchOptions object is used to configure the merge behavior for arrays. In\nthis example, deepPatch is set to true to enable deep patching for arrays.\n\n\n\n\nFunction Signature#\n\n\n\n\nParameters#\n\n * base (Json): The common ancestor JSON object.\n * left (Json): The first JSON object with changes.\n * right (Json): The second JSON object with changes.\n\n\nReturn Value#\n\nThe method returns a ThreeWayMergeResult object:\n\n * conflict (boolean): Indicates if there are conflicts.\n * result (Json | null): The merged JSON object if no conflicts are found,\n   otherwise null.\n * conflicts (PathType[][]): An array of conflict paths if conflicts are found.\n\n\nUsage#\n\n\n\nThe threeWayMerge function helps to merge changes from two JSON objects with a\ncommon ancestor. It generates patches for both the left and right JSON objects\nbased on the base, identifies any conflicts between these patches, and merges\nthem if no conflicts are found. The function returns a result indicating whether\nconflicts were found and, if not, the merged JSON object.","routePath":"/api/threeWayMerge","lang":"","toc":[{"text":"Types","id":"types","depth":2,"charIndex":362},{"text":"PathType","id":"pathtype","depth":3,"charIndex":371},{"text":"Patch Options","id":"patch-options","depth":3,"charIndex":625},{"text":"Function Signature","id":"function-signature","depth":2,"charIndex":799},{"text":"Parameters","id":"parameters","depth":3,"charIndex":823},{"text":"Return Value","id":"return-value","depth":3,"charIndex":993},{"text":"Usage","id":"usage","depth":2,"charIndex":1291}],"domain":"","frontmatter":{"pageType":"doc"},"version":""}]